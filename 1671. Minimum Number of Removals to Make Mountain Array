#Για να λύσουμε αυτό το πρόβλημα, πρέπει να βρούμε τον ελάχιστο αριθμό στοιχείων που πρέπει να αφαιρέσουμε από τον πίνακα nums ώστε να σχηματιστεί ένα "mountain array". Ένας αποτελεσματικός τρόπος είναι να βρούμε τις μέγιστες αυξομειούμενες ακολουθίες και από τις δύο πλευρές του "βουνου" και να συνδυάσουμε τα αποτελέσματα για να υπολογίσουμε πόσα στοιχεία πρέπει να αφαιρέσουμε.

class Solution:
    def minimumMountainRemovals(self, nums: List[int]) -> int:
        n = len(nums)
        if n < 3:
            return 0  # Το ελάχιστο μήκος για mountain array είναι 3

    # Υπολογίζουμε τις Longest Increasing Subsequences (LIS) από την αρχή και το τέλος του πίνακα
        inc = [1] * n
        dec = [1] * n

    # LIS από αριστερά προς δεξιά
    #Χρησιμοποιούμε τον πίνακα inc για να αποθηκεύσουμε το μήκος της μέγιστης αύξουσας υποακολουθίας που τελειώνει σε κάθε στοιχείο.
        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j]:
                    inc[i] = max(inc[i], inc[j] + 1)
        print(inc)

    # LIS από δεξιά προς αριστερά
    #Χρησιμοποιούμε τον πίνακα dec για τη μέγιστη φθίνουσα υποακολουθία που ξεκινάει από κάθε στοιχείο
        for i in range(n - 2, -1, -1):
            for j in range(i + 1, n):
                if nums[i] > nums[j]:
                    dec[i] = max(dec[i], dec[j] + 1)
        print(dec)
    # Βρίσκουμε τη μέγιστη mountain array ακολουθία. (αφαιρώντας το στοιχείο της κορυφής για να μην το μετρήσουμε δύο φορές)
        max_mountain_len = 0
        for i in range(1, n - 1):
            if inc[i] > 1 and dec[i] > 1:  # Το i είναι το "βουνό" (πρέπει να έχει αριστερή και δεξιά αυξομείωση)
                max_mountain_len = max(max_mountain_len, inc[i] + dec[i] - 1)

    # Υπολογισμός του ελάχιστου αριθμού αφαιρούμενων στοιχείων
        return n - max_mountain_len
            
            
            
